/**
 * 动态规划问题
 * 假设 coins = [1, 3, 5, 7, 10]
 * 转化为：求可以凑成金额为i的最少的硬币个数(即：金额i的最优解)
 * 转移方程 dp[i] = Math.min(dp[i-1], dp[i-3], dp[i-5], dp[i-7], dp[i-10]) + 1
 */
function coinChange(coins: number[], amount: number): number {
   let dp = Array.from({ length: amount + 1 }, () => -1); // 增加第0项为填充项
   dp[0] = 0; // 设置金额为0的最优解为0
   for (let i = 1; i <= amount; i++) {
       for (let j = 0; j <= coins.length - 1; j++) {
           if (i - coins[j] >= 0 && dp[i-coins[j]] !== -1) {
               if (dp[i] === -1 || dp[i] > dp[i-coins[j]] + 1) {
                   dp[i] = dp[i-coins[j]] + 1;
               }
           }
       }
   }
   return dp[amount];
};
//runtime:200 ms
//memory:38.6 MB
