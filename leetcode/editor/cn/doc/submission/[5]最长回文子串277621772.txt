/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  // TODO 动态规划
    //* 如果一个子串两头不相等，则该子串不是回文串；如果一个子串两头相等，需要看去掉两头后剩下的子串是否是回文
    //* 定义状态：dp[i][j] 表示子串 s[i..j] 是否为回文串
    //* 状态转移方程： d[i][j] = (s[i] === s[j]) and dp[i + 1][j - 1]
    //* 边界条件(不构成区间)： j - 1 - (i + 1) + 1 < 2 => j - i < 3 = j - i + 1 < 4(s[i..j]长度为 2 或 3 时，不用检查子串是否回文)
    //* 初始化：dp[i][i] = true(单个字符一定是回文串)
    //* 输出：在得到一个状态的值为 true 时，记录起始位置和长度，填表完成以后再截取
    var len = s.length
    if (len < 2) return s
    var maxLength = 1
    var begin = 0
    //* dp[i][j] 表示 s[i..j] 是否是回文串
    var dp = new Array(len).fill(new Array(len).fill(false))
    //* 对角线上的值赋值为 true
    for (var i = 0; i < len; i++) {
        dp[i][i] = true
    }
    //* 注意，根据填表规律，需要先填左下角，先列后行
    for (var j = 1; j < len; j++) {
        for (var i = 0; i < j; i++) {
            if (s[i] !== s[j]) {
                dp[i][j] = false
            } else {
                dp[i][j] = j - i + 1 <= 3 || dp[i + 1][j - 1]
            }

            //* 只要 dp[i][j] = true 成立，就表示 s[i..j] 是回文，此时记录回文长度和起始位置
            if (dp[i][j] && j - i + 1 > maxLength) {
                maxLength = j - i + 1
                begin = i
            }
        }
    }
    return s.substring(begin, begin + maxLength)
};
//total_testcases:180
//total_correct:41
//input_formatted:"abcba"
//expected_output:"abcba"
//code_output:"bcb"
